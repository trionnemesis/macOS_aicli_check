---
description: 根據 .clarify/ 資料夾中的釐清項目，先嘗試自動解答（從映射表、SQL COMMENT、命名慣例推論），再對無法自動解答的項目進行互動式釐清，並將答案即時更新回對應的規格模型檔案（erm.dbml 或 features/*.feature）。
---

目標：依據 Discovery 階段產出的釐清項目，透過**自動解答**與**互動式問答**流程逐一釐清，並將釐清結果即時整合回規格檔案中。

# 執行步驟

## 0. 初始化載入

1. **讀取釐清策略**：載入 `.clarify/overview.md`，取得：
   - 釐清項目總數與分佈
   - 建議的釐清順序（由核心至延伸）
   - 優先級分佈與依賴關係

2. **載入釐清項目**：依照 `overview.md` 建議的順序，讀取所有釐清項目檔案（`.clarify/data/*.md` 和 `.clarify/features/*.md`）

3. **載入現有規格**：將以下規格檔案載入記憶體：
   - `spec/erm.dbml`
   - `spec/features/*.feature`
   - 保持原始格式與結構，供後續增量更新使用
   - **建立術語對照表**：提取所有繁體中文術語（實體名稱、屬性 note、Feature 名稱、步驟用詞），供翻譯時參照

4. **載入自動解答來源**：
   - **SQL Schema**：載入 `WM_schema/WM_10001.sql` 和 `WM_schema/WM_MASTER.sql`
   - **資料模型映射表**：載入 `spec/functional-map/module-database-mapping.md`（優先查詢來源）
   - **程式碼索引**：建立表格名稱 → 關聯表的對照索引

## 1. 自動解答階段（互動前執行）

**在進入互動式問答前，先嘗試從現有資源自動解答每個釐清項目**：

### 1.1 自動解答查詢順序

針對每個釐清項目，依序查詢以下來源：

1. **資料模型映射表**（最優先）：
   - 查詢 `functional-map/module-database-mapping.md` 中的「關聯表」欄位
   - 若釐清項目為「XXX_field_關聯實體為何」，直接從映射表取得答案
   - **置信度：高**

2. **SQL Schema COMMENT**：
   - 查詢 `WM_schema/WM_10001.sql` 和 `WM_schema/WM_MASTER.sql`
   - 提取對應表格/欄位的 `COMMENT` 註解
   - **置信度：高**

3. **現有規格檔案**：
   - 查詢 `spec/erm.dbml` 中該實體的 note 說明
   - 查詢 `spec/features/*.feature` 中相關功能的說明
   - **置信度：高**

4. **推論規則**（見 1.2 節）：
   - 套用命名慣例、欄位名稱自明規則
   - **置信度：中-高**（依規則而定）

5. **程式碼分析**：
   - 搜尋程式碼中的 JOIN 查詢、函數名稱、註解
   - **置信度：中**（需有明確證據）

### 1.2 增強推論規則

#### A. 命名慣例推論規則（適用於「XXX_field_關聯實體為何」）

| 欄位名稱模式 | 推論目標實體 | 置信度 |
|-------------|-------------|--------|
| `course_id` | `Course` / `TermCourse` | 高 |
| `class_id` | `ClassMain` | 高 |
| `board_id` | `BbsBoard` | 高 |
| `school_id` / `school` | `School` | 高 |
| `username` | `Account`（作為外鍵時） | 高 |
| `creator` | `Account` | 高 |
| `examinee` | `Account` | 高 |
| `poster` | `Account` | 高 |
| `exam_id` | `ExamTest` / `HomeworkTest` / `QuestionnaireTest` | 中 |
| `time_id` | 對應的 `*Test` 表 | 中 |
| `node` + `site` | `BbsPost`（複合外鍵） | 高 |
| `parent` + `child` | 自關聯或同類表關聯 | 中 |
| `xxx_id`（通用） | `Xxx` 或 `XxxMain` | 中 |

**驗證步驟**：使用 `grep` 搜尋程式碼中的 JOIN 或 WHERE 條件來驗證推論。

#### B. 欄位名稱自明規則（適用於「XXX_field_欄位用途為何」）

| 欄位名稱 | 直接答案 | 置信度 |
|---------|---------|--------|
| `birthday` | 生日 | 高 |
| `email` | 電子郵件 | 高 |
| `password` / `passwd` | 密碼 | 高 |
| `username` | 使用者帳號 | 高 |
| `first_name` | 名 | 高 |
| `last_name` | 姓 | 高 |
| `realname` | 真實姓名 | 高 |
| `cell_phone` | 手機號碼 | 高 |
| `home_tel` / `office_tel` | 住家電話 / 辦公電話 | 高 |
| `home_address` / `office_address` | 住家地址 / 辦公地址 | 高 |
| `content` | 內容 | 高 |
| `subject` / `title` / `caption` | 標題/名稱 | 高 |
| `create_time` / `add_time` / `reg_time` | 建立時間 | 高 |
| `update_time` / `upd_time` / `modify_time` | 更新時間 | 高 |
| `begin_time` / `open_time` / `start_time` | 開始時間 | 高 |
| `end_time` / `close_time` | 結束時間 | 高 |
| `enable` | 啟用狀態 | 高 |
| `status` / `state` | 狀態 | 高 |
| `score` | 分數 | 高 |
| `comment` | 評語/備註 | 高 |
| `permute` | 排序順序 | 高 |
| `hit` | 點閱次數 | 高 |
| `attach` | 附件 | 高 |
| `ip` / `ip_addr` / `remote_address` | IP 位址 | 高 |
| `lang` / `language` | 語言設定 | 高 |
| `gender` | 性別 | 高 |
| `role` | 角色 | 高 |
| `level` | 等級/層級 | 高 |
| `quota_*` | 配額相關 | 高 |
| `login_times` / `post_times` / `dsc_times` | 登入/發文/討論次數 | 高 |

#### C. 複合主鍵關聯規則

當表格有複合主鍵時：
- 複合主鍵中的 `xxx_id` 欄位通常是外鍵
- 範例：`ClassDirector` 主鍵為 `username + class_id`
  - `username` → 關聯 `Account`
  - `class_id` → 關聯 `ClassMain`
- **置信度：高**（若映射表有對應記錄）

#### D. 主鍵判斷規則

若欄位為該表的 PRIMARY KEY：
- 回答為「主鍵，不關聯其他實體，而是被其他實體關聯」
- 範例：`Account.username` 是主鍵
- **置信度：高**

### 1.3 自動解答判斷標準

**可直接自動解答的情況**：
- `module-database-mapping.md` 中有明確的關聯表定義
- SQL Schema 中有明確的 `COMMENT` 註解
- 現有規格檔案中已有相關說明
- 程式碼中有明確的註解說明
- 欄位名稱符合「欄位名稱自明規則」表格
- 欄位名稱符合「命名慣例推論規則」且有程式碼使用模式驗證
- 複合主鍵中的欄位符合外鍵命名慣例

**需要互動式釐清的情況**：
- 程式碼中找不到相關使用 **且** 無法套用任何推論規則
- 有多種可能的解釋，無法從程式碼或命名慣例判斷
- 涉及業務規則的判斷（如「是否允許負值」「邊界條件」）
- 推論結果置信度為「低」的情況

### 1.4 自動解答結果處理

**對於可自動解答的項目**：

1. **直接更新規格檔案**：
   - 資料模型問題 → 更新 `spec/erm.dbml` 的 note 或關聯定義
   - 功能模型問題 → 更新 `spec/features/*.feature` 的 Rule 或 Example

2. **標記為已解決**：
   - 將釐清項目移至 `.clarify/resolved/` 目錄
   - 更新 `overview.md` 的統計數字
   - 在 resolved 檔案中註記解決記錄，格式如下：

```markdown
---
# 解決記錄

- **回答**：<自動推論的答案>
- **更新的規格檔**：<spec/erm.dbml 或 spec/features/*.feature>
- **變更內容**：<簡述規格檔的變更內容>
- **自動解答來源**：<映射表 / SQL COMMENT / 命名慣例 / 程式碼 / 現有規格>
- **置信度**：<高 / 中>
```

**對於無法自動解答的項目**：
- 保留在待處理佇列中
- 進入「建立釐清佇列」和「互動式問答」流程

### 1.5 自動解答範例

#### 範例 1：從映射表自動解答

**釐清項目**：`ClassDirector_class_id_關聯實體為何.md`

**自動解答流程**：
1. 查詢 `module-database-mapping.md`
2. 找到 `WM_class_director` 的關聯表為 `WM_class_main, WM_all_account`
3. 比對 `class_id` → 對應 `WM_class_main` → 實體為 `ClassMain`
4. **自動解答**：關聯 ClassMain
5. 更新 `spec/erm.dbml` 的 Ref 定義
6. 將釐清項目移至 `.clarify/resolved/data/`，註記來源為「映射表」

#### 範例 2：從欄位名稱自明規則解答

**釐清項目**：`Account_birthday_欄位用途為何.md`

**自動解答流程**：
1. 查詢欄位名稱自明規則表格
2. `birthday` 對應「生日」，置信度：高
3. **自動解答**：生日
4. 更新 `spec/erm.dbml` 的 note
5. 將釐清項目移至 `.clarify/resolved/data/`，註記來源為「欄位名稱自明」

#### 範例 3：從命名慣例 + 程式碼驗證

**釐清項目**：`BbsPost_board_id_關聯實體為何.md`

**自動解答流程**：
1. 套用命名慣例：`board_id` → 可能關聯 `BbsBoard`
2. 使用 `grep` 驗證：搜尋 `bbs_post.*JOIN.*bbs_board` 或 `board_id = bbs_board`
3. 找到程式碼中的使用模式，確認關聯
4. **自動解答**：關聯 BbsBoard，置信度提升為高
5. 更新規格並歸檔

## 2. 建立釐清佇列

根據 `overview.md` 的建議順序，建立優先化的釐清佇列：

### 排序原則

1. **核心優先**：優先處理 High 優先級項目
2. **由核心至延伸**：先處理核心實體與功能，再處理邊界條件與細節
3. **平衡分佈**：在資料模型與功能模型間交替進行，避免連續處理同類問題
4. **依賴關係**：若項目 B 依賴項目 A 的釐清結果，確保 A 先於 B

### 佇列管理

- 初始佇列**僅包含無法自動解答的釐清項目**（自動解答項目已在階段 1 處理完畢）
- 每個項目標記狀態：Pending（待處理）/ In-Progress（處理中）/ Resolved（已解決）/ Skipped（已跳過）
- 使用者可選擇跳過低優先級項目
- 提前終止時，未處理項目標記為 Deferred

## 3. 逐題提問循環（互動式，僅處理無法自動解答的項目）

### 3.1 提問流程

**一次只呈現一題**，格式如下：

\`\`\`
---
[釐清進度：第 X / 總 Y 題] [優先級：High/Medium/Low]

# 問題

<白話翻譯版問題>

## 定位

<ERM：哪個實體的哪個屬性？或是哪個關係？>
<Feature：哪個功能的哪條規則？或是哪個 Example？>

## 選項

<呈現多選題表格>

| 選項 | 描述 |
|--------|-------------|
| A | <選項 A 白話描述> |
| B | <選項 B 白話描述> |
| C | <選項 C 白話描述> |
| D | <選項 D 白話描述>（如有）|
| E | <選項 E 白話描述>（如有）|
| Short | 提供其他簡短答案（<=5 字）|

---
\`\`\`

- 對短答題（無明確離散選項），在選項表格後加註：`格式: 簡短回答 (<=5 字)`

#### 翻譯準則

在呈現問題與選項前，必須先執行白話翻譯，遵循以下準則：

1. **術語一致性檢查**：
   - 載入 `spec/erm.dbml` 和 `spec/features/*.feature` 中該實體/功能的相關區段
   - 提取已使用的繁體中文術語（如實體名稱、屬性的中文 note、Feature 名稱、步驟用詞）
   - 建立「技術詞彙 ↔ 規格中文術語」對照表

2. **問題白話化**：
   - 將英文欄位名稱（如 `price`、`quantity`）替換為規格中已使用的中文術語（如「價格」、「數量」）
   - 可在首次提及時用小括號備註英文名稱，如：「價格 (price)」
   - 將技術詞彙（如「屬性」「欄位」「關係」「約束」）轉換為領域語言（如「資訊」「項目」「關聯」「限制」）
   - 保持問題的完整語義，不簡化技術細節

3. **選項白話化**：
   - 將技術描述轉換為使用者情境語言
   - 移除程式語法符號（如 `>=`、`!=`），改用「大於等於」「不等於」
   - 保持選項間的清晰對比

4. **嚴格禁止**：
   - **禁止發明新術語**：若規格中未定義該概念的中文名稱，保留英文並加小括號備註
   - **禁止語義偏移**：白話化不可改變原始問題的技術含義
   - **禁止不一致用詞**：同一概念在不同釐清題中必須使用相同中文術語

5. **翻譯驗證**：
   - 翻譯後，對照規格檔案確認所有術語皆已在規格中使用過
   - 若發現規格中對同一概念有多種用詞（如「顧客」與「客戶」），優先使用 Feature 檔案中的用詞（因更貼近使用者語言）

#### 翻譯範例

**原始問題**（來自釐清項目檔案）：
> `Product` 實體的 `price` 屬性是否允許 `null` 值？

**翻譯後問題**：
> 商品的價格 (price) 是否可以空白（未設定）？

**原始選項**：
- A: 允許 `null`，表示價格待定
- B: 不允許，必須 `>= 0`

**翻譯後選項**：
- A: 可以空白，表示價格尚未確定
- B: 不可空白，必須是大於等於 0 的數字

### 3.2 回答處理

使用者回答後：

1. **驗證回答**：
   - 檢查回答是否對應某選項（A/B/C/D/E）
   - 若為 Short，確認符合不超過 5~10 字的限制（沒這麼嚴格）
   - 若含糊或不明確，立即要求釐清（仍計入同一題，不前進到下一題）

2. **記錄答案**：
   - 將答案暫存於工作記憶
   - 標記該釐清項目為 Resolved

3. **立即整合**（見步驟 4）

4. **更新進度**：
   - 將該釐清項目從 Pending 改為 Resolved
   - 移至佇列的下一題

### 3.3 終止條件

在下列情況停止繼續提問：

- 所有釐清項目都已處理完畢
- 使用者明確表示終止（如「done」「stop」「no more」「proceed」）
- 剩餘項目僅為 Low 優先級且使用者選擇跳過

**切勿提前透露後續題目**，保持一次一題的節奏。

### 3.4 互動原則

- **單一焦點**：每次只聚焦一個釐清項目，避免混淆
- **快速驗證**：若回答含糊，立即要求釐清，不要臆測
- **進度透明**：每題都顯示進度（第 X / 總 Y 題）
- **優先級可見**：每題都顯示優先級，讓使用者了解重要性

## 4. 立即整合（增量更新）

**每次**答案被接受後，立即執行增量更新：

### 4.0 遵循規格表達規則

**所有**規格檔案的更新都必須依照 [`formulation-rules.md`](./formulation-rules.md) 中的規範執行，包括：
- **核心原則**：無腦補或任意假設原則
- **資料模型萃取規則**：實體、屬性、關係的萃取與標註方式
- **功能模型萃取規則**：Feature、Rule、Example 的萃取與描述方式
- **輸出格式規範**：DBML 與 Gherkin Language 的格式要求

將釐清結果轉換為規格內容時，必須確保符合上述規則的所有要求。

### 4.1 更新策略

根據釐清項目的定位，決定更新目標：

- **資料模型釐清** → 更新 `spec/erm.dbml`（依照 `formulation-rules.md` 的 DBML 格式規範）
  - 更新實體屬性定義（型別、note、約束）
  - 新增或修改關係定義
  - 更新跨屬性不變條件
  - 新增狀態轉換規則

- **功能模型釐清** → 更新 `spec/features/<功能名>.feature`（依照 `formulation-rules.md` 的 Gherkin Language 格式規範）
  - 新增或修改 Rule
  - 新增或修改 Example（遵循 Given-When-Then 格式）
  - 更新前置/後置條件
  - 補充錯誤處理情境

- **術語衝突釐清** → 全文正規化
  - 統一所有規格檔案中的術語
  - 必要時保留「（先前稱為 'X'）」註記（僅一次）

### 4.2 更新原則

- **遵循表達規則**：所有更新必須符合 [`formulation-rules.md`](./formulation-rules.md) 的規範
- **取代而非累加**：若釐清使先前的含糊敘述失效，直接取代，不保留矛盾內容
- **保留格式**：維持原有的標題階層、區段順序、縮排風格
- **精煉可測試**：插入的釐清內容保持精煉且可驗證，避免敘事漂移
- **原子性覆寫**：每次整合後立即儲存規格檔，降低情境遺失風險
- **句型一致**：Feature 檔案中的 Step 定義保持句型一致，避免語義相同但句型不同造成重複實作

### 4.3 整合步驟
每一步都必須扎實做到，不可跳步驟。
1. **定位目標區段**：根據釐清項目的「定位」欄位，找到需更新的實體/屬性/功能/規則
2. **套用釐清**：將答案轉換為對應的 DBML 或 Gherkin 語法，**必須依照 [`formulation-rules.md`](./formulation-rules.md) 的規範執行**
3. **驗證語法**：確保更新後的內容符合 DBML 或 Gherkin 格式
4. **檢查一致性**：確保無矛盾陳述、術語統一
5. **儲存規格檔**：原子性覆寫對應的規格檔
6. **更新釐清項目狀態**：歸檔已處理的釐清項目（見 4.6）

### 4.4 DBML 更新範例

**原始釐清問題**（技術導向）：「MenuItem 的 price 是否允許負值？」

**翻譯後問題**（白話）：「菜品的價格 (price) 是否可以是負數？」

**使用者答案**：「A - 不可以，必須是大於等於 0 的數字」

**規格更新**：

更新前：
`\`\`dbml
Table MenuItem {
  id int [pk]
  price float [note: "菜品價格"]
}
`\`\`

更新後：
`\`\`dbml
Table MenuItem {
  id int [pk]
  price float [note: "菜品價格，必須 >= 0"]
}
`\`\`

### 4.5 Gherkin 更新範例

**原始釐清問題**（技術導向）：「將菜品加入訂單時，quantity 為 0 如何處理？」

**翻譯後問題**（白話）：「將菜品加入訂單時，數量 (quantity) 填 0 該怎麼處理？」

**使用者答案**：「B - 不允許加入，要顯示錯誤訊息」

**規格更新**：

更新前：
`\`\`gherkin
Feature: 將菜品加入訂單

  Rule: 顧客可以將菜品加入訂單
    Example: 成功加入菜品
      Given 菜品「宮保雞丁」存在於菜單中
      When 顧客將「宮保雞丁」加入訂單，數量為 2
      Then 訂單中應有「宮保雞丁」，數量為 2
`\`\`

更新後（新增規則與例子）：
`\`\`gherkin
Feature: 將菜品加入訂單

  Rule: 顧客可以將菜品加入訂單
    Example: 成功加入菜品
      Given 菜品「宮保雞丁」存在於菜單中
      When 顧客將「宮保雞丁」加入訂單，數量為 2
      Then 訂單中應有「宮保雞丁」，數量為 2

  Rule: 加入訂單時數量必須大於 0
    Example: 拒絕數量為 0 的菜品
      Given 菜品「宮保雞丁」存在於菜單中
      When 顧客將「宮保雞丁」加入訂單，數量為 0
      Then 系統顯示錯誤訊息「菜品數量必須大於 0」
      And 訂單中不應有「宮保雞丁」
`\`\`

### 4.6 釐清項目狀態更新

**每次**規格檔更新完成後，立即執行釐清項目歸檔，保持 `.clarify/` 資料夾的可維護性：

#### 步驟 1：在釐清項目檔案底部記錄回答

在移動釐清項目檔案之前，先在該檔案底部追加解決記錄：

`\`\`markdown
---
# 解決記錄

- **回答**：<使用者選擇的選項，如：A - 選項描述>
- **更新的規格檔**：<spec/erm.dbml 或 spec/features/*.feature>
- **變更內容**：<簡述規格檔的變更內容>
`\`\`

範例：
`\`\`markdown
---
# 解決記錄

- **回答**：B - 訂單必須屬於某個使用者（User 1:N Order）
- **更新的規格檔**：spec/erm.dbml
- **變更內容**：在 Order 實體中新增 user_id 外鍵，建立 User 1:N Order 關係
`\`\`

#### 步驟 2：從 overview.md 移除該項目

- 定位該釐清項目在 `.clarify/overview.md` 中的所有出現位置：
  - 「3. 建議釐清順序」中的項目條目
  - 「5. 覆蓋度摘要」中的引用（如適用）
- 完整移除該項目的條目（包括編號、描述、影響說明、依賴/組合標記）
- 不重新編號剩餘項目，保持原有編號以利追蹤
- 更新「1. 釐清項目統計」的計數（總計 -1，對應分類 -1）
- 儲存更新後的 `overview.md`

#### 步驟 3：歸檔釐清項目檔案

- 根據原始檔案路徑，決定目標歸檔路徑：
  - 原路徑：`.clarify/data/<檔案名>.md` → 目標：`.clarify/resolved/data/<檔案名>.md`
  - 原路徑：`.clarify/features/<檔案名>.md` → 目標：`.clarify/resolved/features/<檔案名>.md`
- 確保目標目錄存在（必要時建立 `.clarify/resolved/data/` 或 `.clarify/resolved/features/`）
- 移動檔案至目標路徑（檔案底部已包含步驟 1 加入的解決記錄）

#### 目的與效益

- **記錄決策歷程**：在釐清項目檔案底部記錄回答，保留完整的決策脈絡
- **保持 overview.md 簡潔**：避免隨時間累積已解決項目，便於快速查看剩餘待處理項目
- **保留歷程記錄**：歸檔至 `resolved/` 資料夾，長期維護時可回溯釐清決策
- **結構化管理**：維持 `data/` 與 `features/` 分層，便於後續查詢特定領域的歷史釐清

## 5. 驗證（於每次寫入後與最終完成時）

### 5.1 即時驗證（每次更新後）

- [ ] 更新的區段已移除原本的含糊佔位文字
- [ ] 不存在互相矛盾的陳述
- [ ] 格式有效：
  - `spec/erm.dbml` 遵守 DBML 語法
  - `spec/features/*.feature` 遵守 Gherkin 語法（嚴格階層 Feature > Rule > Example）
  - 新增的 Example 至少包含 When step，且與該 Feature 的系統交互相關
- [ ] 術語一致性：更新後的內容使用標準術語
- [ ] 釐清項目狀態已更新：
  - 釐清項目檔案底部已追加解決記錄（包含回答、更新的規格檔、變更內容）
  - 該項目已從 `.clarify/overview.md` 中移除
  - 釐清項目檔案已移動至 `.clarify/resolved/` 對應資料夾
  - `overview.md` 的統計數字已更新

### 5.2 最終驗證（釐清流程結束後）

- [ ] 每個 Resolved 的釐清項目都對應一次規格更新
- [ ] Feature 檔案中的 Step 句型一致
- [ ] 所有 DBML 實體的屬性都有型別與 note
- [ ] 所有 Feature 的 Rule 都至少有一個 Example（或標記 #TODO）
- [ ] 跨檔案的術語保持一致

## 6. 回報完成（在提問循環結束或提前終止後）

產出詳細的完成報告：

### 6.1 釐清統計

- 總釐清項目數：X 項
- **自動解答（Auto-Resolved）**：A 項（其中高置信度 H 項，中置信度 M 項）
- 互動式釐清（Resolved）：Y 項
- 已跳過（Skipped）：Z 項
- 延後處理（Deferred）：W 項

### 6.2 更新規格檔路徑

列出所有更新過的規格檔案：
- `spec/erm.dbml` - 更新 A, B, C 實體
- `spec/features/將菜品加入訂單.feature` - 新增 2 條規則與 3 個例子
- `spec/features/確認訂單.feature` - 更新 1 條規則與 2 個例子

### 6.3 觸及區段

列出所有觸及的實體、屬性、功能、規則名稱

### 6.4 覆蓋度摘要表

列出每個檢查分類（A1-A6, B1-B5, C1-C2, D1-D2）的最終狀態：

| 分類 | 狀態 | 說明 |
|------|------|------|
| A1. 實體完整性 | Resolved | 原為 Partial，已釐清 Customer 與 Order 關聯 |
| A2. 屬性定義 | Resolved | 原為 Missing，已補充 price 約束 |
| A3. 屬性值邊界條件 | Clear | 原已足夠 |
| B1. 功能識別 | Resolved | 原為 Partial，已釐清折扣套用時機 |
| B2. 規則完整性 | Deferred | 超出使用者終止點，剩餘 2 個 Low 優先級項目 |
| ... | ... | ... |

狀態說明：
- **Resolved**：原為 Partial/Missing 且已釐清
- **Deferred**：因使用者終止或題額限制而延後
- **Clear**：原已足夠，無需釐清
- **Outstanding**：仍為 Partial/Missing 但影響較低

### 6.5 後續建議

- 若所有 High 優先級項目都已 Resolved，建議進入下一階段（規劃或實作）
- 若有 High 優先級項目為 Deferred，建議說明風險並建議再次執行 Formulation
- 若有新發現的歧義（在釐清過程中浮現），建議再次執行 Discovery

## 7. 釐清項目檔案管理

### 預設行為：即時歸檔

本流程採用**即時歸檔**策略：
- 每個釐清項目解決後，立即移動至 `.clarify/resolved/` 資料夾
- 同時從 `overview.md` 移除該項目
- 保留歷程記錄於 `.clarify/resolved/data/` 或 `.clarify/resolved/features/`

### 歸檔結構

`\`\`
.clarify/
├── overview.md          # 僅包含待處理項目
├── data/                # 待處理的資料模型釐清項目
├── features/            # 待處理的功能模型釐清項目
└── resolved/            # 已解決的釐清項目
    ├── data/            # 已解決的資料模型釐清項目
    └── features/        # 已解決的功能模型釐清項目
`\`\`

# 行為規則

## 自動解答規則

- **優先自動解答**：在進入互動式問答前，必須先嘗試所有自動解答途徑
- **映射表優先**：查詢 `module-database-mapping.md` 是最優先的自動解答來源
- **置信度門檻**：僅當置信度為「高」或「中」時才可自動解答；「低」置信度需進入互動式釐清
- **驗證推論**：使用命名慣例推論時，須用 `grep` 搜尋程式碼驗證關聯
- **記錄來源**：每個自動解答的項目必須在 resolved 檔案中註記解答來源與置信度
- **批量處理**：自動解答階段可一次處理多個項目，減少互動負擔

## 互動式問答規則

- **嚴格依序**：按照 `overview.md` 建議的順序提問，不跳題
- **單題單焦點**：一次只呈現一題，等待回答後再進入下一題
- **必先翻譯**：每題提問前，必須先執行白話翻譯，確保問題與選項符合翻譯準則
- **術語精準**：翻譯時必須使用規格檔案中已有的繁體中文術語，嚴禁發明新詞
- **術語對照**：每次翻譯前，從規格檔案中提取該領域的中文術語對照表
- **快速驗證**：若回答含糊，立即要求釐清，不臆測使用者意圖
- **尊重終止**：使用者隨時可終止，已處理的釐清項目標記為 Resolved，未處理的標記為 Deferred

## 整合規則

- **立即整合**：每個答案接受後立即更新規格檔與釐清項目狀態，不延遲
- **即時歸檔**：每個釐清項目解決後，立即從 `overview.md` 移除並移動至 `.clarify/resolved/`
- **保留格式**：更新規格檔時保持原有格式與結構，不重新排序無關區段
- **術語一致**：全文使用統一術語，必要時正規化先前的不一致用詞
- **句型統一**：Feature 檔案中的 Step 定義保持句型一致
- **避免重複**：若釐清使先前敘述失效，直接取代，不保留矛盾內容
- **可測試性**：所有插入的釐清內容都應精煉且可驗證

# 輸出格式要求

1. **互動提問** → 終端輸出或聊天介面
2. **規格更新** → `spec/erm.dbml` 和 `spec/features/*.feature`
3. **釐清項目歸檔**（自動）→ 即時更新 `.clarify/overview.md` 並移動項目至 `.clarify/resolved/`
4. **完成報告** → 終端輸出或回覆訊息
